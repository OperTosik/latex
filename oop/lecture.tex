\documentclass[a4paper, 12pt]{article}

\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[english, russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[left=2cm,right=1.5cm,top=2cm,bottom=2cm]{geometry}
% \usepackage{mathtext}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{etoolbox}
\usepackage{amsthm}
\usepackage{booktabs}
% \usepackage{nicematrix}
\usepackage{graphicx}
% \usepackage{tikz}
% \usepackage{parskip}

%Реализация aug, overbrace и underbrace без nice matrix
\newcommand\aug{\fboxsep=-\fboxrule\!\!\!\fbox{\strut}\!\!\!}
\newcommand\undermat[2]{\makebox[0pt][l]{$\smash{\underbrace
{\phantom{\begin{matrix}#2\end{matrix}}}_{\text{$#1$}}}$}#2}
\newcommand\overmat[2]{\makebox[0pt][l]{$\smash{\overbrace
{\phantom{\begin{matrix}#2\end{matrix}}}^{\text{$#1$}}}$}#2}
\newcommand\tab[1][.5cm]{\hspace*{#1}}
\newcommand\Underset[2]{\underset{\textstyle #1}{#2}}
\newcommand\Overset[2]{\overset{\textstyle #1}{#2}}


\theoremstyle{definition}
\newtheorem*{definition}{Определение}
\newtheorem*{theorem}{Теорема}
\newtheorem*{consequense}{Следствие}
\newtheorem*{lemma}{Лемма}
\newtheorem*{subtheorem}{Утверждение}
\newtheorem*{remark}{Замечание}


\begin{document}
    \fontsize{14pt}{20pt}\selectfont
    \begin{center}
        \begin{Large}
            \textbf{Объектно-ориентированное программирование}
        \end{Large}
    \end{center}
    \begin{definition}
        \textit{Инкапсуляция} -- "заключение в капсулу" ограничение к содержимому "капсулы" извне и отсутствие такого ограничения внутри "капсулы".
    \end{definition}
    По умолчанию, в классе (class) C++ данные и методы приватные (private). Они могут быть прочитаны и изменены только классом к которому принадлежат. Уровень доступа может быть изменен при помощи спецификаторов:
    \begin{itemize}
        \item public -- публичные данные, доступные всем;
        \item protected -- защищенные, доступные только классу и дочерним классам;
        \item private -- данные, доступные только классу, которому они принадлежат.
    \end{itemize}
    
    \begin{definition}
        \textit{Наследование} -- метод, позволяющий описать новый класс на основе уже существующего с частично или полностью заимстваванной функциональностью.  
    \end{definition}
    К примеру на основе одного класса можно построить другой класс. Также данный принцип позволяет создавать иерархии классов, где подклассы наследуют свойства и методы класса, что позволяет избежать дублирование кода.

    \begin{definition}
        \textit{Полиморфизм} -- способность объектов использовать методы класса, проявляя разное поведение в зависимости от своего типа. 
    \end{definition}

    Виды полиморфизма:
    \begin{enumerate}
        \item Полиморфизм подтипов (наследования) -- вид, основанный на наследовании и позволяет объектам дочерних классов использоваться как объекты родительского класса.
        \item Параметрический полиморфизм (обощенное программирование) -- позволяет создавать обобщенные функции и классы, которые могут работать с разными типами данных без знания их конкретной природы.
        \item Полиморфизм в интерфейсах -- позволяет объектам из разных классов реализовывать общий интерфейс и предоставлять схожее поведение без явного наследования.
    \end{enumerate}

    
    
        
\end{document}